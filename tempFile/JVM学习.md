# JVM学习

# 1.JAVA虚拟栈

主要保存着我们常见的数据类型、对对象引用的 reference 类型。

1.main（）方法会进入一个程序进程。进程的执行有最小单位线程完成。而JAVA虚拟机栈的数目与线程有关，再Class加载时，是什么控制了栈的生成？

2.判断变量是否私有来判断线程安全？是否为局部变量？局部变量（针对的是自定义类型）的调用范围是否会超出方法范围？

### 2.虚拟栈内存溢出

（StackOverflowError与OOM的区别？）

（StackOverFlowError:
当启动一个新的线程是虚拟机会为其分配一个新的栈空间，Java栈以帧为单位保证线程运行状态。当线程调用一个方法时JVM会压入一个新的栈帧到这个线程的栈空间中，只要这个方法还没有返回则这个栈帧就会一直存在。所以方法的嵌套调用太多（如递归调用），随着栈帧的增加导致总和大于JVM设置的-Xss值就会抛出StackOverFlowError异常

OutOfMemoryError:
堆内存溢出：当需要为对象示例化分配内存空间时，而堆的占用已经达到了设置的最大值（-Xmx），就会抛出OutOfMemoryError异常。**方法区内存溢出**：方法区存放Java类信息（如类名、访问修饰符、常量池、字段描述、方法描述），在类加载器记载class文件到内存时JVM会提取累的这些信息到方法区，而此时如果需要存储这些类信息且方法区的内存占用已经达到最大值（-XX:MaxPermSize）则会抛出OutOfMemoryError异常。

  ）

#### 1.栈帧过多导致溢出

- 没有终止条件的递归
- 类之间的互相引用

#### 2.栈帧过大导致溢出

### 3.线程诊断

#### 1.CUP占用过高

#### 2.JAVA程序运行时间长无法得出结果

类之间形成的死锁

# 2.本地方法栈

调用操作系统中底层的方法时占用的内存，例如（System、Object）

# 3.JAVA虚拟堆

### 1.特点

是线程共享的，存放类的实例对象。对象在堆中内存主要分为：对象头、实例对象、对齐填充。

### 2.堆内存溢出

（**OOM**）

1.不断地创建对象，且对象有人调用。

2.

### 3.堆内存诊断工具

可以在IDEA编译器下的Terminal窗口输入以下前指令。

1.JPS工具

查看当前系统JAVA进程

2.jmap

-heap （进程数）

**3.jconsole**

多功能，可以检测线程进程堆内存。（图形界面）

### 4.问题

1.垃圾回收后内存占用依然很高

visualvm （可视化虚拟机）然后再堆的dump功能（堆转储）可以对内存进行快照，排查具体占堆内存较大的对象

# 4.方法区

### 1.定义

 方法区是一个线程共享的用于存放类的二进制节码的内存模型。其二进制码代表的是类的结构（类名、类的参数、类的方法代码等等）、以及常量池。可以概括为：**常量池**、类、类加载器。保存着静态变量、常量

区别：

方法区再Hospot虚拟机的1.8版本前时放在JAVA虚拟机堆内存下，并用永生代实现，因此会出现OOM的情况。再1.8版本后则是放在本地内存上。在实现层面已经不在JAVA虚拟堆中了。

### 2.方法区溢出

方法区OOM就是没有足够的方法区内存去给类分配空间。

可以通过**Javap　－V　＜类名＞**来获取类的二进制解码信息。

实践过程中：往往再Spring可能因为框架定义不当生成较多的类导致OOM

### 3.常量池

常量池则保存的一张表，表中的索引可以查找到JAVA代码二进制后的类的索引、类的属性等等。同时也保存这我们定义在的字符串内容。

当运行常量池时，常量池的信息就放入运行时常量池，将索引变成为真正的地址。

### 4.字符串池

1.Code 与 Constant pool

方法区中，编译的class文件中的Code源码会形成常量池，保存方法、类、字符对象等等。这里面的**字符**就保存在常量池中的StringTable[]中。而字符串对象（new）及其**字符值**则是保存在JAVA堆中的。

2.String c = a+b 、String c = 'a'+'b'在JVM中

字符串拼接时时调用的StringBulider（）方法来拼接的最后toString()创建新的字符串对象。因此放在了堆内存

在虚拟机存储层面

3.intern方法

将堆中字符串对象提前入池，如果已经入池则返回池中对象。否则将堆的内容放入池中

4.Hospot1.8以后将StringTable放入了堆内存

5.StringTable由垃圾回收机制

6.StringTable调优

StringTable由哈希表实现的，在垃圾回收可以看到StringTable Statistics

中桶的数量。这决定着哈希表的大小，哈希表太大太小都会影响时间。

1.调整 -XX:StringTableSIze = 桶的个数

2.考虑字符串对象是否需要入池

当有大量的字符串对象时，可以考虑字符串入池来排除大部分重复的对象从而减少内从调用。

# 5.直接内存

1.定义

本地直接内存

2.NIO的缓冲，读写相关。释放分配开销大但是效率高。

NIO申请直接内存，会在操作系统划分一块内存拱JAVA使用、

3.不受JVM垃圾处理控制



# 6.垃圾回收

### 1.判断回收对象

#### 2.可达分析算法（GCROOT类）

MAT软件（下载）帮助堆分析和内存泄漏检测

#### 3.四种引用

1.强

沿着GCroot对象引用路径可以找到的对象

2.软

GCROOT对象间接引用的对象。

条件：1.内存空间GC一次后空间不足则回收

3.弱

相比弱，只要发生GC就直接回收。



作为软引用弱引用的对象再一次GC后放回到引用队列。根据需要进一次释放

4.虚

虚引用就是类引用的就是一个内存地址。



5.FInal（）

### 2.垃圾回收算法

### 3.分代垃圾回收

### 4.垃圾回收器

### 5.调优

# 7.创建对象

## 1.创建对象基本步骤（new）

虚拟机创建对象：

1.判断指令的参数在常量池能否定位到一个符号引用。来判断这个类是否加载编译过。

2.划分JAVA堆内存

3.划分堆内存时候会有线程安全的问题

4.填写对象头信息

5.调用＜ｉｎｉｔ＞

## 2.对象内存布局

## 3.对象的引用定位

# 8.调优

## 1.调优领域

- 内存
- 锁竞争
- CPU占用
- IO

## 2.合适的工具

## 问题

1.JVM中会不断提到线程安全的问题，因此需要复习一遍多线程

2.LINUX排错技能

3.区分对象和变量

