# GITHUB刷题总结

# 剑指OFFER

## 1.数组

1. 二分法

2. 双指针

3. 滑动窗口

4. 原地重排

   

5. 

# 双指针

### 1.双指针主要用于遍历数组。

   可延伸到多个数组的多个指针。通常两个指针遍历方向相同且不相交则为滑动窗口。相反则为搜索查找，且必为最优解。

### 2. NO167  相向遍历搜索

### 3.快慢指针 

例题 142 在这里快慢指针主要用于判断是否构成圈。双指针以不同的速度向后遍历。第一次相遇说明存圈，第二次相遇则是循环链表的起点。

那么如何判断是否要用快慢指针？ 快慢指针可以更进阶吗？

学习经验： 在用leetbook刷题时，应该自己先看这个概念的意思，对着例题原题先用自己的想法实现实现。然后和参考对应，发现自己的不足。1.可以避免“误以为自己会” 2. 可以独立思考 帮助自己进入状态

### 4.滑动窗口

思路问题： 

1. 如何知道滑动窗口内是否包含对应字符串的所有字符？
2. 

# 单调队列

1.单调队列是维护队列内数组元素1.**按照单调递增或递减排列**的数据结构。2.能够**O（1）返回队列内的最大或最小元素**。因此极值肯定要放到队列的出口位置。



关键问题：

1.如何动态的维护数组的元素？

要对进入队列和出队列作某种操作，保证队列内元素单调。

就要对push和pop的操作进行重写。例如动态维护单调递减。我们在push（）时，如何值比队列大，则不停pop直到比队列的值小。那么pop时候呢，我们

例如：

我们需要求出的是滑动窗口的最大值，如果当前的滑动窗口中有两个下标 i 和 j，其中 i 在 j的左侧（i < j），并且 ii 对应的元素不大于 jj 对应的元素（\textit{nums}[i] \leq \textit{nums}[j]nums[i]≤nums[j]），那么会发生什么呢？

当**滑动窗口向右移动时，只要 ii 还在窗口中，那么 jj 一定也还在窗口**中，这是 ii 在 jj 的左侧所保证的。因此，由于 \textit{nums}[j]nums[j] 的存在，\textit{nums}[i]num**s[i] 一定不会是滑动窗口中的最大值了，我们可以将 \textit{nums}[i]nums[i] 永久地移除。**

因此我们可以使用**一个队列存储所有还没有被移除的下标。在队列中，这些下标按照从小到大的顺序被存储**，并且它们在数组 \textit{nums}nums 中对应的值是严格单调递减的。因为如果队列中有两个相邻的下标，它们对应的值相等或者递增，那么令前者为 ii，后者为 jj，就对应了上面所说的情况，即 \textit{nums}[i]nums[i] 会被移除，这就产生了矛盾。

当滑动窗口向右移动时，我们需要把一个新的元素放入队列中。为了保持队列的性质，我们会不断地将新的元素与队尾的元素相比较，**如果前者大于等于后者，那么队尾的元素就可以被永久地移除**，我们将其弹出队列。我们需要不断地进行此项操作，直**到队列为空或者新的元素小于队尾的元素。**

由于队列中下标对应的元素是严格单调递减的，**因此此时队首下标对应的元素就是滑动窗口中的最大值。**但与方法一中相同的是，此时的最大值可能在滑动窗口左边界的左侧，并且随着窗口向右移动，它永远不可能出现在滑动窗口中了。因此我们还需要不断从队首弹出元素，直到队首元素在窗口中为止。

为了可以同时弹出队首和队尾的元素，我们需要使用双端队列。满足这种单调性的双端队列一般称作「单调队列」。

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/
来源：力扣（LeetCode）

# 优先队列

**PriorityQueue（优先队列）**
实际上是一个堆（不指定Comparator时默认为最小堆）
队列既可以根据元素的自然顺序来排序，也可以根据 Comparator来设置排序规则。
队列的头是按指定排序方式的最小元素。如果多个元素都是最小值，则头是其中一个元素。
新建对象的时候可以指定一个初始容量，其容量会自动增加。

**注意1：**该队列是用数组实现，但是数组大小可以动态增加，容量无限。

**注意2：**队列的实现不是同步的。不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问 PriorityQueue实例。保证线程安全可以使用PriorityBlockingQueue 类。

**注意3：**不允许使用 null 元素。

**注意4：**插入方法（offer()、poll()、remove() 、add() 方法）时间复杂度为O(log(n)) ；
remove(Object) 和 contains(Object) 时间复杂度为O(n)；
检索方法（peek、element 和 size）时间复杂度为常量。

**注意5**：方法iterator()中提供的迭代器并不保证以有序的方式遍历优先级队列中的元素。（原因可参考PriorityQueue的内部实现）
如果需要按顺序遍历，可用Arrays.sort(pq.toArray())。

**注意6：**可以在构造函数中指定如何排序。如：
PriorityQueue()使用默认的初始容量（11）创建一个 PriorityQueue，并根据其自然顺序来排序其元素（使用 Comparable）。
PriorityQueue(int initialCapacity)
     使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序来排序其元素（使用 Comparable）。
PriorityQueue(int initialCapacity, Comparator<? super E> comparator)
     使用指定的初始容量创建一个 PriorityQueue，并根据指定的比较器comparator来排序其元素。

**注意7：**此类及其迭代器实现了 Collection 和 Iterator 接口的所有可选 方法。

PriorityQueue对元素采用的是堆排序，**头是按指定排序方式的最小元素。堆排序只能保证根是最大（最小）**，整个堆并不是有序的。
方法iterator()中提供的迭代器可能只是对整个数组的依次遍历。也就只能保证数组的第一个元素是最小的。

## 1.源码学习：

## 2.声名最大最小堆：

  

```java
PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> nums1[a[0]] + nums2[a[1]] - (nums1[b[0]] + nums2[b[1]]));
//声名优先队列 保存【index1，index2】
```



## 3.总结

1.最大最小堆可以帮助我们实时维护一系列数组中的最大最小值。

# JAVA集合

## 1.HashMap

### 1.声名

### 2.定义

### 3.常用方法

### 4.遍历

# 数组和字符串

## 常用的算法思路：

1. ### 前缀和

2. 双指针

3. 二分法

4. 数组和下标建立映射

5. 滑动窗口

6. 善用set hash做contains判断

# 二叉树与递归

二叉树基本上所有的操作都是在遍历的基础上进行的。而且递归的放入顺序决定着不同的作用。

前序遍历，很显然我们就可以先对节点先进行操作，而不依靠后面两个节点。所以可以求高度。

后续遍历，很显然要先对当前节点的左右孩子做操作，要需要先知道孩子节点的结果。所以可以求深度。

## 1.递归与回溯

递归其实就是和回溯差不多的思路。递归我们将结果不断压入递归栈里面。回溯也是记录了调用过的过程，

关键在于如何去回溯。

```java
//单层递归
        if(root.left!=null)
        {
            recursion(root.left,res,path);
            path.remove(path.size()-1);//此处回溯不能放在外面  因为递归调用的顺序中，要一直执行到底层 才能继续往下执行
        }
        if(root.right!=null)
        {
            recursion(root.right,res,path);
            path.remove(path.size()-1);
        }
```



# 回溯算法：

回溯 <---->递归

1.递归的下面就是回溯的过程

2.回溯法是一个 纯暴力的 搜索

3.回溯法解决的问题：

​	3.1组合 如：1234  两两组合

- 组合问题中的去重：

  去重发生在同一树层或者子树层

  去重在树同层去重需要进行排序，从回溯树上来看，重复主要发生在相同数子的节点的子树不断递归造成元素重复。因此如果元素相同我们可以选择跳过。

  **如果`candidates[i] == candidates[i - 1]` 并且 `used[i - 1] == false`，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。

​	3.2切割问题 如：一个字符串有多少个切割方式 ，或者切割出来是回文

​	3.3子集 ： 1 2 3 4  的子集

​	3.4排列问题（顺序）

​	3.5棋盘问题：n皇后  解数独

4.回溯可抽象成树形结构

5.void  backtracking(){

​	if(终止条件)	{

​		收集结果 

​		return

​	}

for(集合的元素集，类似子节点的个数)

​	{

​		处理结点

​		递归函数；

​		回溯操作

​	（撤销处理结点12， 2撤销 ，13 撤销3， 14）

​	}

}

# 动态规划

## 1.DP数组的含义及下标的含义



## 2.递推公式

递推式中类似步长的概念。递推式要有前一个状态得到。那么要计算多少个前状态就是步长。

比如：爬楼梯问题中，每次只能爬1/2层楼梯。因此每次T（n）要从n-1,n-2计算。

## 3.数组的初始化

初始化的正确决定着递归公式最后结果。

可以根据递推公式中上一个子问题的步长来决定要初始化哪些部分。

eg:T(n) = T(n-1)*XX。那么我们就要初始化i=0的部分。

## 4.数组的遍历顺序

思考问题时候 一定要先确定好递推公式。然后才能确认数组遍历顺序。因为遍历顺序是与数组的结构息息相关。但是数组

## 5.数组的打印



## 6.01背包

### 本质：

1. 每个物体只能放一次且其总量是预知的。

### 编写技巧：

1. 如果是二维数组、先遍历背包还是物体本质是相同的。

2. 如果是滚动数组只能先遍历物体再遍历背包且从后往前遍历背包

   ```
   
   for(int i = 0; i < weight.size(); i++) { // 遍历物品
       for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
           dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
   
       }
   }
   //如果先遍历背包就是j不变，从最大容量向最小容量，每次只放入一个价格最高的。
   ```

## 7.完全背包问题

### 实质：物体有无数个且背包有限求放入的最大价值。

01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。

而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：

```cpp
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

1. 硬币求和：
2. 组合求和：（求组合的个数）

### 1.滚动数组

一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。

```java
// 在动态规划中，如果第i个状态只与第i-1个状态有关，而不与其他的例如第i - k(0 < k < i)个状态有关，那么意味着此时
// 在空间上有优化的空间，我们可以采用滚动数组或者从后往前的方式填表来代替开辟更高维度的数组。
// 滚动数组可以理解，但另一种方式是从后往前的方式填表，这是为什么呢？
// 我们可以举个例子，假设一个状态方程为 dp[i][j] = dp[i-1][j-1] + 1;
// 如果采用从后向前填表，那么我们的dp[i-1][j-1]应该是上一轮计算的结果，因为这一轮我们还没有更新过这个值
// 但如果采用从前往后填表，那么我们的dp[i-1][j-1]应该是这一轮计算的结果，因为这一轮我们已经更新过这个值
// 但是我们这个二维dp数组是最初的三维dp数组的一个优化，因此，在状态迁移时，我们需要的是上一轮计算的dp[i-1][j-1]
// 这就是为什么我们要从后往前填表了，主要是保留上一轮计算的结果不被覆盖。
```

### 2.组合问题转化为01背包

本题还是有点难度，大家也可以记住，在求装满背包有几种方法的情况下，递推公式一般为：

```java
dp[j] += dp[j - nums[i]];
```

# 刷题经验总结

1.对于满足一定规律的题，一定要考虑一种极端位置的元素是否可以满足。比如三元递增序列，我们只要找到比第二小的数大的数字就可以成立。

2.

# 优化思路

1.LinkedList替代Stack实现

Stack继承object,

LinkedList可以通过poll（）［返回并删除］　Peek（）［返回不删除］来实现栈的操作。
